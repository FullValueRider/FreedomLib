[Description("Class Var is a replacement for the Variant class.  It provides the metadata of TypeInfo via properties of an encapsulated variable (the cargo)")]
Class Var
    /* 
        Class Var provides TypeInfo data about the encapsulated variable using fluent notation
        e.g. myVar.FirstIndex rather than TypeInfo.FirstIndex(myVar)
        
        The class does not provide any mechanism for changin the value(2) of the encapsulated variable
        
        To do this the encapsulated variable should be reference by the 'Cargo' method
        
        In the case that Cargo encapsulated an Arrray, cargo returns the address of the safearray structure
    */
    Attribute VB_Creatable = True
    Attribute VB_PredeclaredId = True
    Attribute VB_Exposed = True
    Option Explicit
    Option Base 0
    
    Private Type Properties
        ' for debugging perposes
        Message                                 As String
         
        ' the holder of the reference to the external variable
        Cargo                                   As Variant
        ' ' used to preseve original value of cargo if the input is an array
        ' ' used by class terminate event to release copy of array pointer.
        ' Cargobackup                             As Variant
        
        ' Number of dimensions of the variable. Non holders are 0, holders are 1 and multidimensional arrays = number of dimensions.
        Ranks                                   As Long
        IsMissing                               As Boolean
        IsNumeric                               As Boolean
        IsArray                                 As Boolean
        IsArrayInitialized                      As Boolean
        
        ' the id array from TpeInfo.NameToIds
        ' the name array from TypeInfos.FidToNames
        Ids                                     As Variant
        Names                                   As Variant
       
        
        FlibName                                As String
        FlibId                                  As Long
        FirstIndex                              As Variant  ' 1 based array 
        LastIndex                               As Variant  ' 1 based array
        Count                                   As Variant  ' 0 based array.  number of items in valiable.  0 is used for total count for arrays
        
    End Type
 
    Private p                                   As Properties
    
    Const MY_TYPENAME                           As String = "Var"
    Const MY_LOC                                As String = "FreedomLib.Fbase.Var."
    ' Private Sub class_initialize()
    ' End Sub
    
    
    [DefaultMember]
    Public Function Deb(ByRef ipItem As Variant) As Var
        With New Var
            Return .ConstructInstance(ipItem)
        End With
    End Function

    Friend Function ConstructInstance(ByRef ipItem As Variant) As Var
        
        /*
         If ipitem is a parray then var will encapsulate it as a Matrix before storing in Cargo
         NArrys and Uarrays can be copied 'as is' as they don't carry the baggage of a data area
        */
        
        ' 2. Inability to use UDT
        '   For a UDT we can get to this point in twinBasic but we can only determine that it is a UDT we have no access
        '   to any of the udt members and cannot pass it to any of the VBAIs... methods
        
        
        If Not TypeInfo.TryGetIds(ipItem, p.Ids) Then
            Err.Raise 17 + vbObjectError, _
                MY_LOC & CurrentProcedureName, _
                "Type not assigned: " & VBA.TypeName(ipItem)
        End If
        
        ' Trygetids was successful so no need to test for names.
        TypeInfo.TryGetNames VBA.CLng(p.Ids(e_GenreField.m_FLib)), p.Names
        
        p.FlibName = p.Names(e_VarGenre.m_FLib)
        p.FlibId = p.Ids(e_VarGenre.m_FLib)
        /* 
            P.Count has a lower bound of 0 because this is where we store the total number of elements of an array
            First and last index arrays have a lower bound of 1 to match the ranks used in L?UBound statements
        */
        ReDim p.Count(0 To 1)
        ReDim p.FirstIndex(1 To 1)
        ReDim p.LastIndex(1 To 1)
        
        p.Cargo = Empty
       ' p.Cargobackup = 0
        
       /*
            The initialisation routines below are used to setp the first/lastindex properties
       
       */
       
        If p.FlibId(e_GenreField.m_FLib) = e_Id.m_PArray Then
            p.Cargo = Matrix().Bind(ipItem)
        ElseIf VBA.IsObject(ipItem) Then
            Set p.Cargo = ipItem
        Else
            p.Cargo = ipItem
        End If
       
        Select Case p.Ids(e_VarGenre.m_Group)
            
            Case e_Group.m_Admin, e_Group.m_Boolean, e_Group.m_Number, e_Group.m_mpObject
                ' also deals with the case of is missing as missing is part of the admin group.
                InitialiseForSingleValue ipItem
                
            Case e_Group.m_UDT
                InitialiseForUDT
                
            Case e_Group.m_NotInit
                InitialiseForNotInit ipItem
                
            Case e_Group.m_Holder
                
                Select Case p.Ids(e_VarGenre.m_Holder)
                    
                    Case e_Holder.m_String
                        InitialiseForHolderString VBA.CStr(ipItem)
                        
                    Case e_Holder.m_Array
                        InitialiseForHolderArray ipItem
                        
                    Case e_Holder.m_ArrayObj
                        InitialiseforHolderArrayObj
                        
                    Case Else
                        InitialiseforHolderObject ipItem
                
                End Select
                
       End Select
        
        Return Me
        
    End Function

    
    Private Sub InitialiseForHolderString(ByRef ipItem As String)
        
        p.Cargo = ipItem
        p.Count(0) = VBA.Len(ipItem)
        p.Count(1) = p.Count(0)
        p.Ranks = 1
        p.FirstIndex(1) = 1
        p.LastIndex(1) = p.Count(0)
        p.IsArray = False
        p.IsNumeric = VBA.IsNumeric(ipItem)
        p.IsArrayInitialized = False
        p.IsMissing = False
        
    End Sub
    
    Private Sub InitialiseForUDT()
        ' A udt passed as a variant can be determine dto be a UDT using vartype.  No other information is available.
        p.Cargo = Null
        p.Count(0) = 1
        p.Count(1) = 1
        p.Ranks = 0
        p.FirstIndex(1) = 1
        p.LastIndex(1) = -1
        p.IsArray = False
        p.IsArrayInitialized = False
        p.IsNumeric = False
        p.IsMissing = False
            
    End Sub
    
    Private Sub InitialiseForNotInit(ByRef ipArray As Variant)
        
        p.Cargo = ipArray
        p.Ranks = -1
        p.Count(0) = -1
        p.Count(1) = -1
        p.FirstIndex(1) = 0
        p.LastIndex(1) = -1
        p.IsArray = True
        p.IsArrayInitialized = (p.FlibId = e_Id.m_UArray)
       
        p.IsNumeric = False
        p.IsMissing = False
        
    End Sub
    
    
    Private Sub InitialiseForHolderArray(ByRef ipItem As Variant)
        ' a holder array is a PArry (has dimensioned safearraystructure)
        ' Make a backup copy of the cargo variant
        ' this copy will be used in the terminate code to remove the reference to the external array
        [_HiddenModule].vbaCopyBytes Unsafe.myVarSize, ByVal [_HiddenModule].VarPtr(p.Cargobackup), ByVal [_HiddenModule].VarPtr(ipItem)
        ' copy the reference to the external array to p.cargo to avoid copying the array
        [_HiddenModule].vbaCopyBytes Unsafe.myVarSize, ByVal [_HiddenModule].VarPtr(p.Cargo), ByVal [_HiddenModule].VarPtr(ipItem)
        'Lock the array to prevent literal arrays from being destroyed when this method completes
        'current poor workaround for not being able to determine the difference between myArray and Array(1,2,3,4,5)
        Unsafe.LockArray(p.Cargo)
        
        
        p.Ranks = Unsafe.SADims(p.Cargo)
        ReDim p.Count(0 To p.Ranks)
        ReDim p.FirstIndex(1 To p.Ranks)
        ReDim p.LastIndex(1 To p.Ranks)
        p.Count(0) = TypeInfo.Count(p.Cargo)
        Dim myIndex As Long
        For myIndex = 1 To p.Ranks
            p.Count(myIndex) = TypeInfo.Count(p.Cargo, myIndex)
            p.FirstIndex(myIndex) = TypeInfo.FirstIndex(p.Cargo, myIndex)
            p.LastIndex(myIndex) = TypeInfo.LastIndex(p.Cargo, myIndex)
        Next
        
        p.IsArray = True
        p.IsArrayInitialized = True
        p.IsNumeric = False
        p.IsMissing = False
        
    End Sub
    
    Private Sub InitialiseforHolderObject(ByRef ipitem As Variant)
        
        Set p.Cargo = ipitem
        p.Ranks = 1
        p.Count(0) = ipitem.count
        p.Count(1) = p.Count(0)
        
        Select Case p.Ids(e_VarGenre.m_Holder)
            Case e_Holder.m_ItemByIndex0
                p.FirstIndex(1) = 0
                p.LastIndex(1) = p.Count(0) - 1
            Case e_Holder.m_ItemByIndex1
                p.FirstIndex(1) = 1
                p.LastIndex(1) = p.Count(0)
            Case e_Holder.m_ItemByKey
                p.FirstIndex(1) = 1
                p.LastIndex(1) = p.Count(0)
            Case e_Holder.m_ItemByToArray
                p.FirstIndex(1) = 0
                p.LastIndex(1) = p.Count(0) - 1
                
        End Select
        
        p.IsArray = False
        p.IsArrayInitialized = False
        p.IsNumeric = False
        p.IsMissing = False
        
    End Sub
    
    Public Sub InitialiseForSingleValue(ByRef ipItem As Variant)

        If VBA.IsObject(ipItem) Then
            Set p.Cargo = ipItem
        Else
            p.Cargo = ipItem
        End If
        If VBA.IsMissing(ipItem) Then
            p.Count(0) = -1
            p.Count(1) = -1
            p.FirstIndex(1) = 0
            p.LastIndex(1) = -1
            p.IsMissing = True
        Else
            
            p.Count(0) = 1
            p.Count(1) = 1
            p.Ranks = 0
            p.FirstIndex(1) = 1
            p.LastIndex(1) = 1
            p.IsMissing = False
        End If
        p.IsArray = False
        p.IsArrayInitialized = False
        p.IsNumeric = VBA.IsNumeric(ipItem)
        
    End Sub

    Public Property Get Cargo() As Variant
    	Return p.Cargo
    End Property
    

    Public Sub class_Terminate()
    	If Not Me Is Var Then
            ' release the array pointed to by p.cargo.
            'Unsafe.SafeArrayUnlock ByVal ArrayPtr(p.Cargo)
            ' Restore the original content of p.cargo so that the garbage collector
            ' doesn't try to do a double deletion of the safe array.
            [_HiddenModule].vbaCopyBytes Unsafe.myVarSize, ByVal VarPtr(p.Cargo), ByVal VarPtr(p.Cargobackup)
        End If
       
    End Sub
    
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
' FreedomLib Type Names and Ids
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
    [Description("Returns a lower cased name if defined by FreedomLib else vbnullstring)")]
    Public Function Name(Optional ByRef ipGenre As e_VarGenre = e_VarGenre.m_Flib) As String
    	Contract.IsInNumRange ipGenre, e_VarGenre.m_First, e_VarGenre.m_Last, MY_LOC & CurrentProcedureName
        Return p.Names(ipGenre)
    End Function


    [Description("Returns a positive long value if defined by FreedomLib else -1)")]
    Public Function Id(Optional ByRef ipGenre As e_VarGenre = e_VarGenre.m_Flib) As Long
        Contract.IsInNumRange ipGenre, e_VarGenre.m_First, e_VarGenre.m_Last, MY_LOC & CurrentProcedureName
        Return p.Ids(ipGenre)
    End Function

'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
' Alternatives for VBA.IsXXX methods( which are not type specific) together with their complement
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
    'Description ("Method IsArrayInitialized is in TwinBasic but only determines if a safearray struct exists and hence does not distinguish between Unpopulated and Populated arrays. FreedomLib recommends one of the following specific methods IsNArray, IsUArray and IsParray)")
    Public Function IsArrayInitialized() As Boolean
            Return p.IsArrayInitialized
    End Function

    Public Function IsArrayNotInitialized() As Boolean
            Return (Not p.IsArrayInitialized)
    End Function


    Public Function IsMissing() As Boolean
        Return (p.IsMissing)
    End Function

    Public Function IsNotMissing() As Boolean
        Return (Not p.IsMissing)
    End Function

    
    ' Description("FreedomLib suggests you might prefer to use the IsNumber method which avoids the coercion of strings to numbers")
    Public Function IsNumeric() As Boolean
        Return p.IsNumeric
    End Function

    Public Function IsNotNumeric() As Boolean
        Return (Not p.IsNumeric)
    End Function
    
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
'Methods that replicate VBA.Vartype vartype
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========

    Public Function IsEmpty() As Boolean
        Return (p.FlibId = e_Id.m_Empty)
    End Function
            
    Public Function IsNotEmpty() As Boolean
        Return (Not Me.IsEmpty)
    End Function

    Public Function IsDate() As Boolean
        Return (p.FlibId = e_Id.m_Date)
    End Function
        
    Public Function IsNotDate() As Boolean
        Return (Not Me.IsDate)
    End Function

    Public Function IsNull() As Boolean
        Return (p.FlibId = e_Id.m_Null)
    End Function
        
    Public Function IsNotNull() As Boolean
        Return (Not Me.IsNull)
    End Function

    [Description("True if ipItem is 'nothing'. Returns false if ipItem is not an object.  Avoids the unusual 'x is nothing' syntax")]
    Public Function IsNothing() As Boolean
        Return (p.FlibId = e_Id.m_Nothing)
    End Function

    Public Function IsNotNothing() As Boolean
        Return (Not Me.IsNothing)
    End Function


    [Description("Tests for not being an error created using CVErr")]
    Public Function IsError() As Boolean
        Return (p.FlibId = e_Id.m_CVErr)
    End Function
        
    Public Function IsNotError() As Boolean
        IsNotError = (Not Me.IsError)
    End Function

    [Description("Tests for the Err object See IsError and IsNotError for errors generated using CVErr")]
    Public Function IsErrObject() As Boolean
        Return (p.FlibId = e_Id.m_ErrObject)
    End Function
        
    Public Function IsNotErrObject() As Boolean
        Return (Not Me.IsErrObject)
    End Function
        
    Public Function IsObject() As Boolean
        Return (p.Ids(e_VarGenre.m_Entity) = e_Entity.m_Object)
    End Function
        
    Public Function IsNotObject() As Boolean
        Return (Not Me.IsObject)
    End Function

    Public Function IsByte() As Boolean
        Return (p.FlibId = e_Id.m_Byte)
    End Function

    Public Function IsNotByte() As Boolean
        Return (Not Me.IsByte)
    End Function


    Public Function IsInteger() As Boolean
        Return (p.FlibId = e_Id.m_Integer)
    End Function

    Public Function IsNotInteger() As Boolean
        Return (Not Me.IsInteger)
    End Function


    Public Function IsLong() As Boolean
        Return (p.FlibId = e_Id.m_Long)
    End Function

    Public Function IsNotLong() As Boolean
        Return (Not Me.IsLong)
    End Function

    Public Function IsLongLong() As Boolean
        Return (p.FlibId = e_Id.m_LongLong)
    End Function

    Public Function IsNotLonglong() As Boolean
        Return (Not Me.IsLongLong)
    End Function

    Public Function IsSingle() As Boolean
        Return (p.FlibId = e_Id.m_Single)
    End Function

    Public Function IsNotSingle() As Boolean
        Return (Not Me.IsSingle)
    End Function


    Public Function IsDouble() As Boolean
        Return (p.FlibId = e_Id.m_Double)
    End Function

    Public Function isNotDouble() As Boolean
        Return (Not Me.IsDouble)
    End Function


    Public Function IsCurrency() As Boolean
        Return (p.FlibId = e_Id.m_Currency)
    End Function

    Public Function IsNotCurrency() As Boolean
        Return (Not Me.IsCurrency)
    End Function


    Public Function IsDecimal() As Boolean
        Return (p.FlibId = e_Id.m_Decimal)
    End Function

    Public Function IsNotDecimal() As Boolean
        Return (Not Me.IsDecimal)
    End Function
    
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
' Entity functions
    ' m_NotDefined
    ' m_Simple = &H300                           ' holds a single value* that can be assigned without set
    ' m_First = e_Entity.m_Simple
    ' m_UserDefinedType                          ' a grouping of variables which are accessible using unique names qualified by the parent name 
    ' m_Array
    ' m_Last
    ' m_Object = m_Last  
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========

    Public Function IsSimple() As Boolean
        Return p.Ids(e_VarGenre.m_Entity) = e_Entity.m_Simple
    End Function

    Public Function IsNotSimple() As Boolean
        Return (Not Me.IsSimple)
    End Function


    Public Function IsUDT() As Boolean
        Return p.Ids(e_VarGenre.m_Entity) = e_Entity.m_UserDefinedType
    End Function

    Public Function IsNotUDT() As Boolean
        Return (Not Me.IsUDT)
    End Function

    'IsArray see group methods
    'isObject see vbvartype methods
    
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
' Group functions
    ' m_NotAssigned = -1
    ' m_NotInit
    ' m_Admin = &H500' null, nothing, errobject, error(CVErr) and empty are grouped on the basis that thier most common use is in the control of program flow.
    ' m_First = e_group.m_Admin
    ' m_Boolean
    ' m_Number
    ' m_UDT
    ' m_mpObject  ' multiple value object
    ' m_Last
    ' m_Holder = e_group.m_Last
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
    Public Function IsAdmin() As Boolean
        Return p.Ids(e_VarGenre.m_Group) = e_Group.m_Admin
    End Function

    Public Function IsNotAdmin() As Boolean
        Return (Not Me.IsAdmin)
    End Function


    '@Description("True if ipItem is a Boolean.  Exludes objects with a default member returning a Boolean")
    Public Function IsBoolean() As Boolean
        Return p.Ids(e_VarGenre.m_Group) = e_Group.m_Boolean
    End Function


    Public Function IsNotBoolean() As Boolean
        IsNotBoolean = (Not Me.IsBoolean)
    End Function


    '@Dewscription("True if ipItem is a Number.  Excludes objects with a default member returning a Number")
    Public Function IsNumber() As Boolean
        Return p.Ids(e_VarGenre.m_Group) = e_Group.m_Number
    End Function

    Public Function IsNotNumber() As Boolean
        Return (Not Me.IsNumber)
    End Function

    'IsUdt see entity functions
    
    Public Function IsmpObject() As Boolean
        Return p.Ids(e_VarGenre.m_Group) = e_Group.m_mpObject
    End Function
    
    Public Function IsNotmpObject() As Boolean
        Return (Not Me.IsmpObject)
    End Function
    
    Public Function IsHolder() As Boolean
        Return p.Ids(e_VarGenre.m_Group) = e_Group.m_Holder
    End Function
    
    Public Function IsNotHolder() As Boolean
        Return (Not IsHolder)
    End Function


'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
' Holder methods
    ' m_NotAssigned = -1
    ' m_IsNotHolder = &H400                           ' the variable does not hold multiple values
    ' m_First = e_Holder.m_IsNotHolder
    ' m_String                                        ' Has multiple values that can be retrieved by an key or single method that takes an key
    ' m_Array                                         ' variable which contain multiple distinct values  - array, containers,
    ' m_ItemByIndex0
    ' m_ItemByIndex1
    ' m_ItemByKey
    ' m_ItemByToArray                                        ' Objects which contain multiple values  ' avoids the use of ItemsObject which is too close to itemObject                               ' Objects which contain multiple values which require values to be extracted as an array( or some other indexable entity) to allow indexing  = e.g.  Stack, Queue
    ' m_last = 1 << 6
    ' m_Mapper = m_Last      
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========

    '@Description("True if ipItem is a String. Excludes objects with a default member returning a String")
    Public Function IsString() As Boolean
        Return (p.Ids(e_VarGenre.m_Holder) = e_Holder.m_String)
    End Function

    '@Description("False if ipItem is a String. Excludes objects with a default member returning a String")
    Public Function IsNotString() As Boolean
        IsNotString = (Not Me.IsString)
    End Function

    [Description("Returns the value of VBA.IsArray")]
    Public Function IsArray() As Boolean
        Return p.IsArray
    End Function
    
    Public Function IsNotArray() As Boolean
        Return (Not Me.IsArray)
    End Function


    Public Function IsItemByIndex1() As Boolean
        Return (p.Ids(e_VarGenre.m_Holder) = e_Holder.m_ItemByIndex1)
    End Function

    Public Function IsNotItemByIndex1() As Boolean
        Return (Not Me.IsItemByIndex1)
    End Function


    Public Function IsItemByIndex0() As Boolean
        Return (p.Ids(e_VarGenre.m_Holder) = e_Holder.m_ItemByIndex0)
    End Function

    Public Function IsNotItemByIndex0() As Boolean
        Return (Not Me.IsItemByIndex0)
    End Function


    Public Function IsItemByKey() As Boolean
        Return (p.Ids(e_VarGenre.m_Holder) = e_Holder.m_ItemByKey)
    End Function

    Public Function IsNotItemByKey() As Boolean
        Return (Not Me.IsItemByKey)
    End Function


    Public Function IsItemByToArray() As Boolean
        Return (p.Ids(e_VarGenre.m_Holder) = e_Holder.m_ItemByToArray)
    End Function

    Public Function IsNotItemByToArray() As Boolean
        Return (Not Me.IsItemByToArray)
    End Function


    Public Function IsMapper() As Boolean
        Return (p.Ids(e_VarGenre.m_Holder) = e_Holder.m_Mapper)
    End Function

    Public Function IsNotMapper() As Boolean
        Return (Not Me.IsMapper)
    End Function
    
    
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
'flib
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========

    Public Function Bounds() As Variant
        
        Dim myFirstIndexes As Variant
        ReDim myFirstIndexes(1 To p.Ranks)
        
        Dim myLastIndexes As Variant
        ReDim myLastIndexes(1 To p.Ranks)
        
        Dim myIndex As Long
        For myIndex = 1 To p.Ranks
            myFirstIndexes(myIndex) = p.FirstIndex(myIndex)
            myLastIndexes(myIndex) = p.LastIndex(myIndex)
        Next
        
        Return Array(myFirstIndexes, myLastIndexes)
        
    End Function
    
    [Description("Returns true if the variable is an array with no dimensions e.g. Dim myArray() as long")]
    Public Function IsNArray() As Boolean
        Return p.FlibId = e_Id.m_NArray
    End Function
    
    Public Function IsNotNArray() As Boolean
        Return (Not Me.IsNArray)
    End Function
    
    [Description("Returns true if the variable is an array with an initialised safearray structre but no dimensions e.g. Array()")]
    Public Function IsUArray() As Boolean
        Return p.FlibId = e_Id.m_UArray
    End Function
    
    Public Function IsNotUArray() As Boolean
        Return (Not Me.IsUArray)
    End Function
    
    [Description("Returns true if Variable is an array with defined dimensions  e.g. Dim myArray(x to y) or redim myArray(x to y)")]
    Public Function IsPArray() As Boolean
        Return p.Ids(e_VarGenre.m_FLib) = e_Id.m_PArray
    End Function
    
    Public Function IsNotPArray() As Boolean
        Return (Not Me.IsPArray)
    End Function
    
    
    Public Function IsMatrix() As Boolean
        Return p.Ids(e_VarGenre.m_FLib) = e_Id.m_Matrix
    End Function
    
    Public Function IsNotMatrix() As Boolean
        Return Not Me.IsMatrix
    End Function
' review implied property methods to ensure consistent performance across all types
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
'Implied property methods
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
'The first an last index value ensure that at least one pass of a for loop
' is executed **if** the value can be evaluated
' Simple variables                      values of 1,1
' Udt get                               values of 0,-1
' narrays and uarrays                   values of 0,-1
' holders get values which represent startindexes and count.
    [Description("Returns the first index of the specified rank.  ipRanks Defaults to 1 for holder types")]
    Public Function FirstIndex(Optional ipRank As Long = 1) As Long
        If p.Ranks < 0 Then Return 0
        If ipRank = 0 Then Return 1&
        If ipRank < 1 Then Return 0
        
        Return p.FirstIndex(ipRank)
    End Function

    [Description("Returns the last index of the specified rank. Returns -1 for non-holder. Defaults to rank 1 for holders)")]
    Public Function LastIndex(Optional ipRank As Long = 1) As Long
        If p.Ranks < 0 Then Return -1
        If ipRank = 0 Then Return 1&
        If ipRank < 1 Then Return -1&
        
        Return p.LastIndex(ipRank)
    End Function

    [Description("Returns True if variable is a holder type and contins 1 or more values")]
    Public Function HoldsItems() As Boolean
        Return (p.Ranks > 0 And p.Count(0) > 0)
    End Function

    Public Function LacksItems() As Boolean
        Return Not Me.HoldsItems
    End Function

   
    [Description("returns the number of values per access method represented by the variable. Non holders are 1, empty holders and unallocated arrays return -1,")]
    Public Function Count(Optional ipRank As Long = 0) As Long
        If ipRank < 0 Then Return -1&
        If p.Ranks = 0 Then Return 1&
        If ipRank > p.Ranks Then Return -1&
        Return p.Count(ipRank)
    End Function

    '[ Description ("Returns true if the variable is a single dimension array populated with a single item which is a single dimension array (i.e. a forwarded paramarray))]
    Public Function IsLikeParamArray(ByRef ipItem As Variant) As Boolean
    
        If Not VBA.IsArray(ipItem) Then
            Return False
        End If
    
        If Not VBA.IsArrayInitialized(ipItem) Then
            Return False
        End If
    
        If UBound(ipItem, 1) <> LBound(ipItem(1)) Then
            Return False
        End If
    
        If Not VBA.IsArray(ipItem(0)) Then
            Return False
        End If
    
        If LBound(ipItem(0)) <> UBound(ipItem(0)) Then
            Return False
        End If
    
        Return True
    
    End Function


    [Description(" returns the number of ranks represented by a variable, non holders return 0, arrays return the number of dimensuons otherwise 1")]
    Public Function Ranks() As Long
        Return p.Ranks
    End Function

    ' Description ("Returns true if the specified variable has access to the ranks")
    Public Function HoldsRank(ByVal ipRank As Long) As Boolean
        If ipRank < 1 Then Return False
        Return p.Ranks <= ipRank
    End Function

    Public Function LacksRanks(ByVal ipRank As Long, ByRef ipArray As Variant) As Boolean
        Return Not HoldsRank(ipRank)
    End Function



    [Description("Returns the name 'TypeInfo'")]
    Public Property Get TypeName() As String
        Return MY_TYPENAME
    End Property

    Private Sub TypeNotAssigned(ByRef ipItem As Variant, ByRef ipLoc As String)
        Err.Raise 17 + vbObjectError, _
            "Freedomlib.FBase.TypeInfo." & ipLoc, _
            "Type " & VBA.TypeName(ipItem) & " not known to FreedomLib"
    End Sub
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
'Convenience methods
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
    
    Public Property Get IsCollection() As Boolean
        Return p.Ids(e_VarGenre.m_FLib) = e_Id.m_Collection
    End Property
End Class