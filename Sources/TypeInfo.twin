
[Description("The TypeInfo class provides a set of enumrations " _
 & vbcrlf & "and methods that allow reasoning about Types in a more " _
 & vbcrlf & "straightforward and extended manner than afforded by a " _
 & vbcrlf & "simple combination of vba.vartype and vba.TypeName.")]
 ' To do:
 ' Review if we need to add isobject tests to methods

Class TypeInfo
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========

    Attribute VB_Creatable = True
    Attribute VB_PredeclaredId = True
    Attribute VB_Exposed = True

    Option Explicit
    Option Base 0
    
    
    Private Const NOT_ASSIGNED                  As Long = -1
    Private Const MY_LOC                        As String = "FreedomLib.FBase.TypeInfo."
    ' # Type Genres
    ' e_VarGenre defines the genres that used by freedomlib when classifying Types/Variables
    Public Enum e_VarGenre
    	
        m_None = NOT_ASSIGNED
        
        ' Expanded vartype system where all assigned types have a name and Id. 
        ' Not all types need to be assigned
        ' The Id is always unique per Type. Name may encompass several related types, 
        ' e.g. 'array' rather than Long() , udt, multi property (mp)Objects)
        m_FLib
        
        ' to allow 'first' to 'last' in for next loops
        m_First = e_VarGenre.m_FLib
        
        'Pass thru of the VB type system
        m_VBA
        m_Group
        m_Entity
        m_Holder
        m_NotAssigned
        m_Last = e_VarGenre.m_NotAssigned
        
    End Enum
    
    Public Enum e_Entity
        m_NotAssigned = NOT_ASSIGNED
    	m_Simple = &H300                           ' holds a single value* that can be assigned without set
        m_First = e_Entity.m_Simple
        m_UserDefinedType                          ' a grouping of variables which are accessible using unique names qualified by the parent name 
        m_Array
        m_Last
        m_Object = m_Last
        
    End Enum
    
    ' Public Enum e_ObjectType
    ' 	m_IsNotObject = -1
    '     m_Compound = &H200                          ' Object has one of more values accessed by a uniquely named property/function
    '     m_Holder                                    ' Object holds multiple values access by a single keyed method.
    ' End Enum
    
    ' *  Strings are considered to hold multiple values (characters).  It is the user that interprets a single lexical value from the sequence of characters.
    ' ** Key in the most general sense of one value being used to return a second value
    
    ' need some mechanism to flag e_Holder that this is an enum of bit positions
    ' to reflect that a holder may meet more than one requirement
    Public Enum e_Holder
        m_NotAssigned = NOT_ASSIGNED
        m_IsNotHolder = &H400                           ' the variable does not hold multiple values
        m_First = e_Holder.m_IsNotHolder
        m_String
        m_Array
        m_ArrayObj
        m_ItemByIndex0
        m_ItemByIndex1
        m_ItemByKey
        m_ItemByToArray                                        ' Objects which contain multiple values  ' avoids the use of ItemsObject which is too close to itemObject                               ' Objects which contain multiple values which require values to be extracted as an array( or some other indexable entity) to allow indexing  = e.g.  Stack, Queue
        m_last
        m_Mapper = m_Last                               ' Objects that contain multiple values and which support the MaptIt, FilterIt, CountIt and ReduceIt methods - seq, kvp
    End Enum
   
   ' Groups are used to simplify testing of the Type so we are classifying by behaviour
    Public Enum e_Group
    	m_NotAssigned = -1
        m_NotInit
        m_Admin = &H500' null, nothing, errobject, error(CVErr) and empty are grouped on the basis that thier most common use is in the control of program flow.
        m_First = e_group.m_Admin
        m_Boolean
        m_Number
        m_UDT
        m_mpObject  ' multiple property object
        m_Last
        m_Holder = e_group.m_Last
    End Enum
    
    Public Enum e_GenreField
        
        m_None = NOT_ASSIGNED
        m_FLib = 0
        m_VBA
        m_Group
        m_Entity
        m_Holder
    End Enum

    
    ' TypeIds used by FreedomLib
    Public Enum e_Id
        m_NotAssigned = NOT_ASSIGNED
        m_Empty = VT_EMPTY          ' 0
        m_Null = VT_NULL            ' 1
        m_Integer = VT_I2           ' 2
        m_Long = VT_I4              ' 3
        m_Single = VT_R4            ' 4
        m_Double = VT_R8            ' 5
        m_Currency = VT_CY          ' 6
        m_Date = VT_DATE            ' 7
        m_String = VT_BSTR          ' 8
        m_Object = VT_DISPATCH      ' 9  ' also used for Nothing because nothing is an object (with name of Nothing)
        m_CVErr = VT_ERROR          ' 10
        m_Boolean = VT_BOOL         ' 11
        m_Variant = VT_VARIANT      ' 12  ' defined but not usable in VBA/TB
        m_ErrObject = VT_UNKNOWN     ' 13  - vbDataObject
        m_Decimal = VT_DECIMAL      ' 14
    
        m_Byte = VT_UI1             ' 17
        m_LongLong = VT_I8          ' 20
        m_UDT = VT_RECORD           ' 36 vbUnserDefinedType
        ' the following definitions are defined for freedomlib
        ' the type ID's have no correlations in TB/VBA
        m_mpObject  ' object that is not a holder or otherwise affigned in flib
        m_Array = VT_ARRAY          ' 8192  &H2000  Never used on its own in VBA/TB but in compination with another ENUMVAR
        'VBA defined objects
        m_Nothing = &H100           ' nothing has a vbVartype of 9 which is Object (VT_DISPATCH)
        m_Missing                   ' Missing variants are a 'parameter not found error' from a COm perspective. See VarEnum in unsafe
        m_Collection
        m_Debug
        m_UserForm
    
        ' scripting runtime
    
        m_Drive
        m_Drives
        m_File
        m_FileSystemObject
        m_Folder
        m_TextStream
    
        ' FreedomLib
        ' alternatively from mscorlib
        m_ArrayList
        m_Dictionary
        m_Queue
        m_Stack
        
        m_Stringifier
        m_StrFormat
        m_TypeMarkup
        m_Strs
        m_Sys
    
        m_Args
        m_NArray            ' N)il array - Lbound gives error
        m_UArray            ' U)npopulated Lbound > Ubound
        m_PArray            ' P)opulated array Ubound >= Lbound
        
        m_cHashD
        m_TNode
        m_Treap
    
        m_Maths
        m_TypeInfo
        m_Var
    
        m_SeqA
        m_SeqAL
        m_SeqC
        m_SeqH
        m_SeqT
        m_SeqS
        m_SeqQ
    
        m_KVPair
        m_KvpA
        m_KvpC
        m_KvpH
        m_KvpT
    
        m_Matrix    'A matrix  either has no array(waiting for a bind action) or has a populated array
        End Enum
   
    Public Enum e_NumberType
        m_Any
        m_Integer
        m_Float
    End Enum
    ' Public Enum e_ArrayStatus
    '     m_VBA
    '     m_Declared          ' Dim myArray() as <Type>
    '     m_Initialised       ' Dim myArray as variant = Array()
    '     m_Populated         ' Dim  myArray(x to y) as <Type> or Dim myArray as variant = Array(1,2,3,4,5)
    ' End Enum
    
    Const MY_TYPENAME                                   As String = "TypeInfo"
    Private Type State
        
        ' Genre information by FType nameing scheme
        FNameToIds As Treap
        FIdToNames As Treap
    End Type
    
    Private s                                           As State
        
    '    
    Private Sub class_Initialize()
        
        If Not Me Is TypeInfo Then
            Err.Raise 17 + vbObjectError, _
            MY_LOC & CurrentProcedureName, _
            "TypeInfo is intended to be a singleton.  Instances of TypeInfo are not permitted"
        End If
        
        InitFNameToIds
        InitFidToNames
        
        If s.FNameToIds.Count <> s.FIdToNames.Count Then
            Err.Raise 17 + vbObjectError, _
            "FreedomLib.FBase.TypeInfo.Class_Initialize", _
            "The size of FNameToIds does not match the size of FIdToNames. Did you forget to update FidToNames after adding a Type to FNameToIds"
        	
        End If
        
    End Sub
    
    [Description("Initialise the dictionary with FreedomLib Ids vs Genre Ids")]
    Private Sub InitFNameToIds()
    	
        If s.FNameToIds IsNot Nothing Then
        	Exit Sub
        End If
        
    	Set s.FNameToIds = Treap()
    	' The names used for keys are provided by the TypeInfo.FName method
        ' for genreinfo, it is best to do edits using the table in idArray.md and to then copy/[ast below]
        With s.FNameToIds
            .Add "null", Array(e_Id.m_Null, vbNull, e_Group.m_Admin, e_Entity.m_Simple, e_Holder.m_IsNotHolder)
            .Add "empty", Array(e_Id.m_Empty, vbEmpty, e_Group.m_Admin, e_Entity.m_Simple, e_Holder.m_IsNotHolder)
            .Add "nothing", Array(e_Id.m_Nothing, vbObject, e_Group.m_Admin, e_Entity.m_Simple, e_Holder.m_IsNotHolder)  ' we made nothing a simple value even though VBA defines it as an object because a null pointer is not an object
            .Add "cverr", Array(e_Id.m_CVErr, vbError, e_Group.m_Admin, e_Entity.m_Simple, e_Holder.m_IsNotHolder)
            ' vbvartype(err) = vbDataObject which corresponds to VT_IUnknown
            .Add "errobject", Array(e_Id.m_ErrObject, vbDataObject, e_Group.m_Admin, e_Entity.m_Simple, e_Holder.m_IsNotHolder)
            .Add "missing", Array(e_Id.m_Missing, vbError, e_Group.m_Admin, e_Entity.m_Simple, e_Holder.m_IsNotHolder)
            .Add "boolean", Array(e_Id.m_Boolean, vbBoolean, e_Group.m_Boolean, e_Entity.m_Simple, e_Holder.m_IsNotHolder)
            .Add "byte", Array(e_Id.m_Byte, vbByte, e_Group.m_Number, e_Entity.m_Simple, e_Holder.m_IsNotHolder)
            .Add "integer", Array(e_Id.m_Integer, vbInteger, e_Group.m_Number, e_Entity.m_Simple, e_Holder.m_IsNotHolder)
            .Add "long", Array(e_Id.m_Long, vbLong, e_Group.m_Number, e_Entity.m_Simple, e_Holder.m_IsNotHolder)
            .Add "longlong", Array(e_Id.m_LongLong, vbLongLong, e_Group.m_Number, e_Entity.m_Simple, e_Holder.m_IsNotHolder)
            .Add "single", Array(e_Id.m_Single, vbSingle, e_Group.m_Number, e_Entity.m_Simple, e_Holder.m_IsNotHolder)
            .Add "double", Array(e_Id.m_Double, vbDouble, e_Group.m_Number, e_Entity.m_Simple, e_Holder.m_IsNotHolder)
            .Add "currency", Array(e_Id.m_Currency, vbCurrency, e_Group.m_Number, e_Entity.m_Simple, e_Holder.m_IsNotHolder)
            .Add "decimal", Array(e_Id.m_Decimal, vbDecimal, e_Group.m_Number, e_Entity.m_Simple, e_Holder.m_IsNotHolder)
            .Add "date", Array(e_Id.m_Date, vbDate, e_Group.m_Number, e_Entity.m_Simple, e_Holder.m_IsNotHolder)
            .Add "string", Array(e_Id.m_String, vbString, e_Group.m_Holder, e_Entity.m_Simple, e_Holder.m_String)
            ' there are three states for when VBA.ISArray is true
            ' hence we have three names for an array (narray, uarray, parray)
            ' Array declared, no safearray structure e.g.Dim myArray() as Type - Gives error with ubound
            .Add "narray", Array(e_Id.m_NArray, vbArray, e_Group.m_NotInit, e_Entity.m_Array, e_Holder.m_IsNotHolder)
            
            ' Array declared, safearray structure initialised but no data area e.g.Dim myA as variant = Array() - Lbound > Ubound
            .Add "uarray", Array(e_Id.m_UArray, vbArray, e_Group.m_NotInit, e_Entity.m_Array, e_Holder.m_IsNotHolder)
            
            ' Array declared, safearray structure initialised with data area  e.g. Dim myArray(x to y) UBound >= LBound
            .Add "parray", Array(e_Id.m_PArray, vbArray, e_Group.m_Holder, e_Entity.m_Array, e_Holder.m_Array)
            
            ' the vbA.vartype of a user defined type is 36 (VT_Record)
            .Add "udt", Array(e_Id.m_UDT, vbUserDefinedType, e_Group.m_UDT, e_Entity.m_UserDefinedType, e_Holder.m_IsNotHolder)
            'mv object is the name assigned to an object that is not a holder and which otherwise has not been added to flib
            .Add "mpobject", Array(e_Id.m_mpObject, vbObject, e_Group.m_mpObject, e_Entity.m_Object, e_Holder.m_IsNotHolder)
            'This is where we would add user defined types
            .Add "args", Array(e_Id.m_Args, vbObject, e_Group.m_Holder, e_Entity.m_Object, e_Holder.m_ItemByIndex1)
            .Add "collection", Array(e_Id.m_Collection, vbObject, e_Group.m_Holder, e_Entity.m_Object, e_Holder.m_ItemByIndex1)
            .Add "chashd", Array(e_Id.m_cHashD, vbObject, e_Group.m_Holder, e_Entity.m_Object, e_Holder.m_ItemByKey)
            .Add "dictionary", Array(e_Id.m_Dictionary, vbObject, e_Group.m_Holder, e_Entity.m_Object, e_Holder.m_ItemByKey)
            .Add "queue", Array(e_Id.m_Queue, vbObject, e_Group.m_Holder, e_Entity.m_Object, e_Holder.m_ItemByToArray)
            
            '.Add "maths", Array(e_Id.m_Maths, vbObject, e_Group.m_mpObject, e_Entity.m_Object, e_Holder.m_IsNotHolder)
            .Add "stack", Array(e_Id.m_Stack, vbObject, e_Group.m_Holder, e_Entity.m_Object, e_Holder.m_ItemByToArray)
            '.Add "strs", Array(e_Id.m_Strs, vbObject, e_Group.m_mpObject, e_Entity.m_Object, e_Holder.m_IsNotHolder)
            '.Add "strformat", Array(e_Id.m_StrFormat, vbObject, e_Group.m_mpObject, e_Entity.m_Object, e_Holder.m_IsNotHolder)
            .Add "arraylist", Array(e_Id.m_ArrayList, vbObject, e_Group.m_Holder, e_Entity.m_Object, e_Holder.m_ItemByIndex0)
            
            .Add "tnode", Array(e_Id.m_TNode, vbObject, e_Group.m_mpObject, e_Entity.m_Object, e_Holder.m_IsNotHolder)
            .Add "treap", Array(e_Id.m_Treap, vbObject, e_Group.m_Holder, e_Entity.m_Object, e_Holder.m_ItemByKey)
            .Add "matrix", Array(e_Id.m_Matrix, vbObject, e_Group.m_Holder, e_Entity.m_Object, e_Holder.m_ArrayObj)
            ' .Add "seqa", Array(e_Id.m_SeqA, vbObject, e_Group.m_Holder, e_Entity.m_Object, e_Holder.m_ItemByIndex1)
            ' .Add "seqal", Array(e_Id.m_SeqAL, vbObject, e_Group.m_Holder, e_Entity.m_Object, e_Holder.m_ItemByIndex1)
            ' .Add "seqc", Array(e_Id.m_SeqC, vbObject, e_Group.m_Holder, e_Entity.m_Object, e_Holder.m_ItemByIndex1)
            
            ' .Add "seqh", Array(e_Id.m_SeqH, vbObject, e_Group.m_Holder, e_Entity.m_Object, e_Holder.m_ItemByIndex1)
            ' .Add "seqt", Array(e_Id.m_SeqT, vbObject, e_Group.m_Holder, e_Entity.m_Object, e_Holder.m_ItemByIndex1)
            ' .Add "kvpair", Array(e_Id.m_KVPair, vbObject, e_Group.m_Holder, e_Entity.m_Object, e_Holder.m_ItemByKey)
            ' .Add "kvpa", Array(e_Id.m_KvpA, vbObject, e_Group.m_Holder, e_Entity.m_Object, e_Holder.m_ItemByKey)
            ' .Add "kvpc", Array(e_Id.m_KvpC, vbObject, e_Group.m_Holder, e_Entity.m_Object, e_Holder.m_ItemByKey)
            
            ' .Add "kvpH", Array(e_Id.m_KvpH, vbObject, e_Group.m_Holder, e_Entity.m_Object, e_Holder.m_ItemByKey)
            ' .Add "kvpT", Array(e_Id.m_KvpT, vbObject, e_Group.m_Holder, e_Entity.m_Object, e_Holder.m_ItemByKey)
            
        End With
        
    End Sub
    
    
    Private Sub InitFidToNames()
    	
        If s.FIdToNames IsNot Nothing Then
        	Exit Sub
        End If
        
        Set s.FIdToNames = Treap()
        With s.FIdToNames
            .Add e_Id.m_Null, Array("null", "Null", "admin", "simple", "isnotholder")
            .Add e_Id.m_Empty, Array("empty", "Empty", "admin", "simple", "isnotholder")
            .Add e_Id.m_Nothing, Array("nothing", "Nothing", "admin", "simple", "isnotholder")
            .Add e_Id.m_CVErr, Array("cverr", "Error", "admin", "simple", "isnotholder")
            .Add e_Id.m_ErrObject, Array("errobject", "Error", "admin", "simple", "isnotholder")
            .Add e_Id.m_Missing, Array("missing", "Error", "admin", "simple", "isnotholder")
            
            .Add e_Id.m_Boolean, Array("boolean", "Boolean", "boolean", "simple", "isnotholder")
            .Add e_Id.m_Byte, Array("byte", "Byte", "number", "simple", "isnotholder")
            .Add e_Id.m_Integer, Array("integer", "Integer", "number", "simple", "isnotholder")
            .Add e_Id.m_Long, Array("long", "Long", "number", "simple", "isnotholder")
            .Add e_Id.m_LongLong, Array("longlong", "LongLong", "number", "simple", "isnotholder")
            
            .Add e_Id.m_Single, Array("single", "Single", "number", "simple", "isnotholder")
            .Add e_Id.m_Double, Array("double", "Double", "number", "simple", "isnotholder")
            .Add e_Id.m_Currency, Array("currency", "Currency", "number", "simple", "isnotholder")
            .Add e_Id.m_Decimal, Array("decimal", "Decimal", "number", "simple", "isnotholder")
            .Add e_Id.m_Date, Array("date", "Date", "number", "simple", "isnotholder")
            
            .Add e_Id.m_String, Array("string", "String", "holder", "simple", "string")
            .Add e_Id.m_NArray, Array("narray", "Array", "notinit", "array", "isnotholder")
            .Add e_Id.m_UArray, Array("uarray", "Array", "notinit", "array", "isnotholder")
            .Add e_Id.m_PArray, Array("parray", "Array", "holder", "array", "array")
            .Add e_Id.m_UDT, Array("udt", "UDT", "udt", "udt", "isnotholder")
            
            .Add e_Id.m_mpObject, Array("mpobject", "mpObject", "mpobject", "object", "isnotholder")
            
            .Add e_Id.m_Args, Array("args", "Args", "holder ", "object", "itembyindex1")
            .Add e_Id.m_Collection, Array("collection", "Collection", "holder", "object", "itembyindex1")
            .Add e_Id.m_cHashD, Array("chashd", "cHashD", "holder", "object", "itembykey")
            .Add e_Id.m_Dictionary, Array("dictionary", "Dictionary", "holder", "object", "itembykey")
            .Add e_Id.m_Queue, Array("queue", "Queue", "holder", "object", "itembytoarray")
            
            '.Add e_Id.m_Maths, Array("maths", "Maths", "mpObject", "object", "isnotholder")
            .Add e_Id.m_Stack, Array("stack", "Stack", "holder", "object", "itembytoarray")
           ' .Add e_Id.m_Strs, Array("strs", "Strs", "mvbject", "object", "isnotholder")
           ' .Add e_Id.m_StrFormat, Array("strformat", "StrFormat", "mpObject", "object", "isnotholder")
            .Add e_Id.m_ArrayList, Array("arraylist", "ArrayList", "holder", "object", "itembyindex0")
            
            .Add e_Id.m_TNode, Array("tnode", "TNode", "mpObject", "object", "isnotholder")
            .Add e_Id.m_Treap, Array("treap", "Treap", "holder", "object", "itembykey")
            .Add e_Id.m_Matrix, Array("matrix", "Matrix", "holder", "object", "matrix")
          '  .Add e_Id.m_SeqA, Array("seqa", "SeqA", "holder", "object", "itembyindex1")
           ' .Add e_Id.m_SeqAL, Array("seqal", "SeqAL", "holder", "object", "itembyindex1")
          '  .Add e_Id.m_SeqC, Array("seqc", "SeqC", "holder", "object", "itembyindex1")
            
          '  .Add e_Id.m_SeqH, Array("seqh", "SeqH", "holder", "object", "itembyindex1")
          ' .Add e_Id.m_SeqT, Array("seqt", "SeqT", "holder", "object", "itembyindex1")
          '  .Add e_Id.m_KVPair, Array("kvpair", "KVPair", "holder", "object", "itembykey")
          '  .Add e_Id.m_KvpC, Array("kvpc", "KvpC", "holder", "object", "itembykey")
            
          '  .Add e_Id.m_KvpH, Array("kvph", "KvpH", "holder", "object", "itembykey")
          '  .Add e_Id.m_KvpT, Array("kvpt", "KvpT", "holder", "object", "itembykey")
        End With
    End Sub
    
    Public Function TypeIsKnown(ByRef IpItem As String) As Boolean
        Dim myIds As Variant
        Return TryGetIds(IpItem, myIds)
    End Function
    
    
    '@Description("Returns the text name of the type as determined by FreedomLib.  FreedomLib names are always provided in lowercase. The returned type name may not be known by FreedomLib")
    Private Function GetFlibName(ByRef ipItem As Variant) As String
    
        ' ## Name of User defined types (UDT)
        ' VBA does not permit forwarding of a UDT as a variant (error is raised at compile time at parameter list).
        ' In TB, forwarding a UDT as a variant parameter gives an unsupported Type in the called method
        ' Fortunately vba.vartype works on the unsupported Type returning the correct 36 (vbUserDefinedType).
        ' Therefore we can successfully determine that we found a udt 
        ' without having to get embroiled in 'on error' chicanery
        ' No other functions are possible on a udt forwarded as a variant.
        ' In TB, VBA.Typename on a UDT returns the string "$"
        If VBA.VarType(ipItem) = vbUserDefinedType Then
            Return "udt"
        End If
        
        Dim myName As String = VBA.LCase$(VBA.TypeName(ipItem))
        
        Select Case True
            
       
            ' In VBA, Arrays can exist in 3 states depending on the level of initialisation/Instantiation
            ' The case of 'Dim myArray() as Type' does not initialise bounds so Lbound gives an error
            ' The case of 'DIm myArray as variant = Array()' gives a safearray structure and Ubound < LBound (0,-1 or 1,0 depending on option base)
            ' The case of 'Dim myArray( x to y) or redim myArray(x to y)' gives a safearray struct where Ubound>= Lbound
            Case VBA.IsArray(ipItem)
                ' For arrays we only need to know that it is an array, not the type stored in the array
                ' we can avoid using on error for Lbound by using the new tb IsArrayInitialized method
                If Not Me.IsArrayInitialized(ipItem) Then
                    Return "narray"

                ElseIf UBound(ipItem) < LBound(ipItem) Then
                    Return "uarray"
            
                Else
                    Return "parray"
                    
                End If
            
            ' a uarray will be detected as a missing value to this test must come after the tests for array
            Case VBA.IsMissing(ipItem)
                Return "missing"
             
            ' need to separate out objects 'nothing' and 'holders' from multi property objects
            Case VBA.IsObject(ipItem)
        	
                If ipItem Is Nothing Then
                    Return myName
                End If
                
                ' The err 'object' does not return true for isobject so can be ignored here
                ' Typically mpObjects are not defined by name in freedom lib but generically as mpObjects (multi value objects)
                If s.FNameToIds.LacksKey(myName) Then
                    Return "mpobject"
                    ' but for the odd few mpObject that are assigned ids
                ElseIf s.FNameToIds.Item(myName)(e_GenreField.m_VBA) = vbDataObject Then
                    Return "mpobject" ' MultiValueObject
                End If
            
        
        Case VBA.IsError(ipItem)
        	Return "cverr"
        
        End Select
        
        Return myName
        
    End Function
    
   
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
' FreedomLib Type Names and Ids
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
    [Description("Returns a lower cased name if defined by FreedomLib else vbnullstring)")]
    Public Function Name(ByRef ipItem As Variant, Optional ByRef ipGenre As e_VarGenre = e_VarGenre.m_Flib) As String
    	
    	Contract.IsInNumRange ipGenre, e_VarGenre.m_First, e_VarGenre.m_Last, MY_LOC & CurrentProcedureName
        
        Dim myIds As Variant
        If TryGetIds(ipItem, myIds) Then
            Return s.FIdToNames.Item(myIds(e_GenreField.m_FLib))(ipGenre)
        End If
        
        Return vbNullString

    End Function
    
    
    [Description("Returns a positive long value if defined by FreedomLib else -1)")]
    Public Function Id(ByRef ipItem As Variant, Optional ByRef ipGenre As e_VarGenre = e_VarGenre.m_Flib) As Long
        
        Contract.IsInNumRange ipGenre, e_VarGenre.m_First, e_VarGenre.m_Last, MY_LOC & CurrentProcedureName
        Contract.HasId ipItem, MY_LOC & CurrentProcedureName

        Dim myName As String = GetFlibName(ipItem)

        Return s.FNameToIds.Item(myName)(ipGenre)

    End Function
    
    
    [Description("If True the array of Genre names corresponding to ipId is returned in iopNames")]
    Friend Function TryGetNames(ByRef ipId As e_Id, ByRef iopNames As Variant) As Boolean
            
        If s.FIdToNames.LacksKey(ipId) Then
            Return False
        End If
                
        iopNames = s.FIdToNames.Item(ipId)
        
   Return True
        
        
   End Function
    [Description("If True the array of GenreIds corresponding to the FlibName of ipItem is returned in ioPIds")]
    Friend Function TryGetIds(ByRef ipItem As Variant, ByRef iopIds As Variant) As Boolean
    	
    	Dim myName As String = GetFlibName(ipItem)
       
        If s.FNameToIds.LacksKey(myName) Then
        	Return False
        End If
        
        iopIds = s.FNameToIds.Item(myName)
        Return True
        
    End Function
    
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
' Alternatives for VBA.IsXXX methods( which are not type specific) together with their complement.
' Methods that refer to metadata i.e. a proprty of a variable rather than the variable value itself
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
    'Description ("Method IsArrayInitialized is by TwinBasic but does not differentiate between allocated and unallocated arrays. FreedomLib recommends one of the following specific methods IsNArray, IsUArray and IsParray)")
    Public Function IsArrayInitialized(ByRef ipItem As Variant) As Boolean
            Return VBA.IsArrayInitialized(ipItem)
    End Function
    
    Public Function IsArrayNotInitialized(ByRef ipItem As Variant) As Boolean
            Return (Not Me.IsArrayInitialized(ipItem))
    End Function
    

    Public Function IsMissing(ByRef ipItem As Variant) As Boolean
        Return VBA.IsMissing(ipItem)
    End Function

    Public Function IsNotMissing(ByRef ipItem As Variant) As Boolean
        Return (Not Me.IsMissing(ipItem))
    End Function
    
    ' Description("FreedomLib suggests you might prefer to use the IsNumber method which avoids the coercion of strings to numbers")
    Public Function IsNumeric(ByRef ipItem As Variant) As Boolean
        Return VBA.IsNumeric(ipItem)
    End Function

    Public Function IsNotNumeric(ByRef ipItem As Variant) As Boolean
        Return (Not Me.IsNumeric(ipItem))
    End Function
    
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
' Methods that replicate the functionality of VBA.Vartype 
' Methods that refer to the value of a variable
' To eliminate issues due to default values we do not use VBA.IS...
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========

    Public Function IsEmpty(ByRef ipItem As Variant) As Boolean
        Dim myIds As Variant
        If TryGetIds(ipItem, myIds) Then
            Return (myIds(e_GenreField.m_FLib) = e_Id.m_Empty)
        Else
            Return False
        End If
        
        'Return (s.FNameToIds.Item(GetFlibName(ipItem))(e_GenreField.m_FLib) = e_Id.m_Empty)
    End Function
            
    Public Function IsNotEmpty(ByRef ipItem As Variant) As Boolean
        Return (Not Me.IsEmpty(ipItem))
    End Function
    

    Public Function IsDate(ByRef ipItem As Variant) As Boolean
        Dim myIds As Variant
        If TryGetIds(ipItem, myIds) Then
            Return (myIds(e_GenreField.m_FLib) = e_Id.m_Date)
        Else
            Return False
        End If
        
        'Return (s.FNameToIds.Item(GetFlibName(ipItem))(e_GenreField.m_FLib) = e_Id.m_Date)
    End Function
        
    Public Function IsNotDate(ByRef ipItem As Variant) As Boolean
        Return (Not Me.IsDate(ipItem))
    End Function
    

    Public Function IsNull(ByRef ipItem As Variant) As Boolean
        Dim myIds As Variant
        If TryGetIds(ipItem, myIds) Then
            Return (myIds(e_GenreField.m_FLib) = e_Id.m_Null)
        Else
            Return False
        End If
        
        'Return (s.FNameToIds.Item(GetFlibName(ipItem))(e_GenreField.m_FLib) = e_Id.m_Null)
    End Function
        
    Public Function IsNotNull(ByRef ipItem As Variant) As Boolean
        Return (Not Me.IsNull(ipItem))
    End Function

    
    [Description("True if ipItem is 'nothing'. Returns false if ipItem is not an object.  Avoids the unusual 'x is nothing' syntax")]
    Public Function IsNothing(ByRef ipItem As Variant) As Boolean
        Dim myIds As Variant
        If TryGetIds(ipItem, myIds) Then
            Return (myIds(e_GenreField.m_FLib) = e_Id.m_Nothing)
        Else
            Return False
        End If
        
        'Return (s.FNameToIds.Item(GetFlibName(ipItem))(e_GenreField.m_FLib) = e_Id.m_Nothing)
    End Function

    Public Function IsNotNothing(ByRef ipItem As Variant) As Boolean
        Return (Not Me.IsNothing(ipItem))
    End Function


    [Description("Tests for not being an error created using CVErr")]
    Public Function IsError(ByRef ipItem As Variant) As Boolean
        Dim myIds As Variant
        If TryGetIds(ipItem, myIds) Then
            Return (myIds(e_GenreField.m_FLib) = e_Id.m_CVErr)
        Else
            Return False
        End If
        
        'Return (s.FNameToIds.Item(GetFlibName(ipItem))(e_GenreField.m_FLib) = e_Id.m_CVErr)
    End Function
        
    Public Function IsNotError(ByRef ipItem As Variant) As Boolean
        IsNotError = Not Me.IsError(ipItem)
    End Function

    
    [Description("Tests for the Err object See IsError and IsNotError for errors generated using CVErr")]
    Public Function IsErrObject(ByRef ipItem As Variant) As Boolean
        Dim myIds As Variant
        If TryGetIds(ipItem, myIds) Then
            Return (myIds(e_GenreField.m_FLib) = e_Id.m_ErrObject)
        Else
            Return False
        End If
        
        'Return s.FNameToIds.Item(GetFlibName(ipItem))(e_GenreField.m_FLib) = e_Id.m_ErrObject
    End Function
        
    Public Function IsNotErrObject(ByRef ipitem As Variant) As Boolean
        Return Not Me.IsErrObject(ipitem)
    End Function
        
    
    Public Function IsObject(ByRef ipItem As Variant) As Boolean
            
        If Not VBA.IsObject(ipItem) Then
            Return False
        End If
            
        If ipItem Is Nothing Then
            Return False
        End If
            
        ' If VBA.TypeName(ipItem) = "ErrObject" Then
        '     Return False
        ' End If
            
        Return True
            
    End Function
        
    Public Function IsNotObject(ByRef ipItem As Variant) As Boolean
        Return (Not Me.IsObject(ipItem))
    End Function
    

    Public Function IsByte(ByRef ipitem As Variant) As Boolean
        Dim myIds As Variant
        If TryGetIds(ipitem, myIds) Then
            Return (myIds(e_GenreField.m_FLib) = e_Id.m_Byte)
        Else
            Return False
        End If
        
        'Return s.FNameToIds.Item(GetFlibName(ipitem))(e_GenreField.m_FLib) = e_Id.m_Byte
    End Function

    Public Function IsNotByte(ByRef ipItem As Variant) As Boolean
        Return Not IsByte(ipItem)
    End Function


    Public Function IsInteger(ByRef ipItem As Variant) As Boolean
        Dim myIds As Variant
        If TryGetIds(ipItem, myIds) Then
            Return (myIds(e_GenreField.m_FLib) = e_Id.m_Integer)
        Else
            Return False
        End If
        
        'Return (s.FNameToIds.Item(GetFlibName(ipItem))(e_GenreField.m_FLib) = e_Id.m_Integer)
    End Function

    Public Function IsNotInteger(ByRef ipItem As Variant) As Boolean
        Return (Not IsInteger(ipItem))
    End Function


    Public Function IsLong(ByRef ipitem As Variant) As Boolean
        Dim myIds As Variant
        If TryGetIds(ipitem, myIds) Then
            Return (myIds(e_GenreField.m_FLib) = e_Id.m_Long)
        Else
            Return False
        End If
        
        'Return (s.FNameToIds.Item(GetFlibName(ipitem))(e_GenreField.m_FLib) = e_Id.m_Long)
    End Function

    Public Function IsNotLong(ByRef ipItem As Variant) As Boolean
        Return (Not IsLong(ipItem))
    End Function
    

    Public Function IsLongLong(ByRef ipItem As Variant) As Boolean
        Dim myIds As Variant
        If TryGetIds(ipItem, myIds) Then
            Return (myIds(e_GenreField.m_FLib) = e_Id.m_LongLong)
        Else
            Return False
        End If
        
        'Return (s.FNameToIds.Item(GetFlibName(ipItem))(e_GenreField.m_FLib) = e_Id.m_LongLong)
    End Function

    Public Function IsNotLonglong(ByRef ipItem As Variant) As Boolean
        Return (Not IsLongLong(ipItem))
    End Function
    

    Public Function IsSingle(ByRef ipitem As Variant) As Boolean
        Dim myIds As Variant
        If TryGetIds(ipitem, myIds) Then
            Return (myIds(e_GenreField.m_FLib) = e_Id.m_Single)
        Else
            Return False
        End If
        
        'Return (s.FNameToIds.Item(GetFlibName(ipitem))(e_GenreField.m_FLib) = e_Id.m_Single)
    End Function

    Public Function IsNotSingle(ByRef ipItem As Variant) As Boolean
        Return (Not IsSingle(ipItem))
    End Function


    Public Function IsDouble(ByRef ipItem As Variant) As Boolean
        Dim myIds As Variant
        If TryGetIds(ipItem, myIds) Then
            Return (myIds(e_GenreField.m_FLib) = e_Id.m_Double)
        Else
            Return False
        End If
        
        'Return (s.FNameToIds.Item(GetFlibName(ipItem))(e_GenreField.m_FLib) = e_Id.m_Double)
    End Function

    Public Function isNotDouble(ByRef ipItem As Variant) As Boolean
        Return (Not IsDouble(ipItem))
    End Function


    Public Function IsCurrency(ByRef ipItem As Variant) As Boolean
        Dim myIds As Variant
        If TryGetIds(ipItem, myIds) Then
            Return (myIds(e_GenreField.m_FLib) = e_Id.m_Currency)
        Else
            Return False
        End If
        
        'Return (s.FNameToIds.Item(GetFlibName(ipItem))(e_GenreField.m_FLib) = e_Id.m_Currency)
    End Function

    Public Function IsNotCurrency(ByRef ipItem As Variant) As Boolean
        Return (Not IsCurrency(ipItem))
    End Function


    Public Function IsDecimal(ByRef ipItem As Variant) As Boolean
        Dim myIds As Variant
        If TryGetIds(ipItem, myIds) Then
            Return (myIds(e_GenreField.m_FLib) = e_Id.m_Decimal)
        Else
            Return False
        End If
        
        'Return (s.FNameToIds.Item(GetFlibName(ipItem))(e_GenreField.m_FLib) = e_Id.m_Decimal)
    End Function

    Public Function IsNotDecimal(ByRef ipItem As Variant) As Boolean
        Return (Not IsDecimal(ipItem))
    End Function
    
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
' Methods relating to the Entity assignment
'   m_NotDefined
'   m_Simple = &H300                           ' holds a single value* that can be assigned without set
'   m_First = e_Entity.m_Simple
'   m_UserDefinedType                          ' a grouping of variables which are accessible using unique names qualified by the parent name 
'   m_Array
'   m_Last
'   m_Object = m_Last  
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
    
     Public Function IsSimple(ByRef ipItem As Variant) As Boolean
        Dim myIds As Variant = Empty
        If TryGetIds(ipItem, myIds) Then
            Return (myIds(e_GenreField.m_Entity) = e_Entity.m_Simple)
        End If
        Return False
    End Function

    Public Function IsNotSimple(ByRef ipItem As Variant) As Boolean
        Return (Not Me.IsSimple(ipItem))
    End Function


    Public Function IsUDT(ByRef ipItem As Variant) As Boolean
        Dim myIds As Variant = Empty
        If TryGetIds(ipItem, myIds) Then
            Return (myIds(e_GenreField.m_Entity) = e_Entity.m_UserDefinedType)
        End If
        Return False
    End Function

    Public Function IsNotUDT(ByRef ipItem As Variant) As Boolean
        Return (Not IsUDT(ipItem))
    End Function

    
    Public Function IsArray(ByRef ipItem As Variant) As Boolean
        Dim myIds As Variant
        If TryGetIds(ipItem, myIds) Then
            Return (myIds(e_GenreField.m_Entity) = e_Entity.m_Array)
        End If
        Return False
    End Function
        
    Public Function IsNotArray(ByRef ipItem As Variant) As Boolean
        Return (Not Me.IsArray(ipItem))
    End Function

    '========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
    ' Methods related to the Groupassignments
        ' m_NotAssigned = -1
        ' m_NotInit
        ' m_Admin = &H500' null, nothing, errobject, error(CVErr) and empty are grouped on the basis that thier most common use is in the control of program flow.
        ' m_First = e_group.m_Admin
        ' m_Boolean
        ' m_Number
        ' m_UDT
        ' m_mpObject  ' multiple value object
        ' m_Last
        ' m_Holder = e_group.m_Last
    '========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
    Public Function IsAdmin(ByRef ipItem As Variant) As Boolean
    	Dim myIds As Variant
        If TryGetIds(ipItem, myIds) Then
            Return (myIds(e_GenreField.m_Group) = e_Group.m_Admin)
        End If
        Return False
    End Function

    Public Function IsNotAdmin(ByRef ipitem As Variant) As Boolean
        Return (Not Me.IsAdmin(ipitem))
    End Function


    '@Description("True if ipItem is a Boolean.  Exludes objects with a default member returning a Boolean")
    Public Function IsBoolean(ByRef ipItem As Variant) As Boolean
        Dim myIds As Variant
        If TryGetIds(ipItem, myIds) Then
            Return (myIds(e_GenreField.m_Group) = e_Group.m_Boolean)
        End If
        Return False
    End Function

    Public Function IsNotBoolean(ByRef ipItem As Variant) As Boolean
        IsNotBoolean = (Not IsBoolean(ipItem))
    End Function


    '@Dewscription("True if ipItem is a Number.  Excludes objects with a default member returning a Number.  Optionally can test if a number is an integer value or float value (NB Value not Type)")
    Public Function IsNumber(ByRef ipItem As Variant, Optional ipNumType As e_NumberType = m_any) As Boolean
        Dim myIds As Variant
        If Not TryGetIds(ipItem, myIds) Then
           Return False
        End If
        
        If (myIds(e_GenreField.m_Group) <> e_Group.m_Number) Then
            Return False
        End If
        
        ' would a string solution be quicker? i.e. convert to string and test for '.'
        
        Dim IsInteger As Boolean = ((ipItem - VBA.Round(ipItem, 0)) = 0)
    
        Select Case ipNumType
            
            Case e_NumberType.m_Any
                Return True
                
            Case e_NumberType.m_Integer
                Return IsInteger
                
            Case Else
                Return Not IsInteger
               
        End Select
            
    End Function

    Public Function IsNotNumber(ByRef ipItem As Variant) As Boolean
        Return (Not IsNumber(ipItem))
    End Function

    [Description("True if the object is not intended to be a holder object, i.e. has one or more properties like PointXY")]
    Public Function IsmpObject(ByRef ipItem As Variant) As Boolean
        Dim myIds As Variant = Empty
        If TryGetIds(ipItem, myIds) Then
            Return (myIds(e_GenreField.m_Group) = e_Group.m_mpObject)
        End If
        Return False
    End Function

    Public Function IsNotmpObject(ByRef ipItem As Variant) As Boolean
        Return (Not IsmpObject(ipItem))
    End Function
    
    
    Public Function IsHolder(ByRef ipItem As Variant) As Boolean
        Dim myIds As Variant = Empty
        If TryGetIds(ipItem, myIds) Then
            Return (myIds(e_GenreField.m_Entity) = e_Entity.m_Object)
        End If
        Return False
    End Function
    
    Public Function IsNotHolder(ByRef ipItem As Variant) As Boolean
        Return (Not IsHolder(ipItem))
    End Function

'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
' Methods relating to the Holder assignment
    ' m_NotAssigned = -1
    ' m_IsNotHolder = &H400                           ' the variable does not hold multiple values
    ' m_First = e_Holder.m_IsNotHolder
    ' m_String                                        ' Has multiple values that can be retrieved by an key or single method that takes an key
    ' m_Array                                         ' variable which contain multiple distinct values  - array, containers,
    ' m_ItemByIndex0
    ' m_ItemByIndex1
    ' m_ItemByKey
    ' m_ItemByToArray                                        ' Objects which contain multiple values  ' avoids the use of ItemsObject which is too close to itemObject                               ' Objects which contain multiple values which require values to be extracted as an array( or some other indexable entity) to allow indexing  = e.g.  Stack, Queue
    ' m_last = 1 << 6
    ' m_Mapper = m_Last      
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
    '@Description("Returns true if ipItem is a container where Items are retrieved by an Item method with the Index starting at 1 e.g. Collection and Seq classes")
    
    '@Description("True if ipItem is a String. Excludes objects with a default member returning a String")
    Public Function IsString(ByRef ipItem As Variant) As Boolean
       
        ' If VBA.IsObject(ipItem) Then
        '     Return False
        ' End If
        
        Dim myIds As Variant
        If TryGetIds(ipItem, myIds) Then
            Return (myIds(e_GenreField.m_Holder) = e_Holder.m_String)
        End If
        Return False
    End Function

    Public Function IsNotString(ByRef ipItem As Variant) As Boolean
        IsNotString = (Not IsString(ipItem))
    End Function
    
    
    Public Function IsItemByIndex1(ByRef ipItem As Variant) As Boolean
    	
    	If Not VBA.IsObject(ipItem) Then
        	Return False
    	End If
        
        Dim myIds As Variant
        If TryGetIds(ipItem, myIds) Then
           Return (myIds(e_GenreField.m_Holder) = e_Holder.m_ItemByIndex1)
        End If
        
        Return False
        
    End Function
    
    Public Function IsNotItemByIndex1(ByRef ipItem As Variant) As Boolean
        Return Not IsItemByIndex1(ipItem)
    End Function


    '@Description("Returns True if ipItem is a container where Items are retrieved by an Item method with the index starting at 0 e.g. mscorlib ArrayList")
    Public Function IsItemByIndex0(ByRef ipItem As Variant) As Boolean
    	
        If Not VBA.IsObject(ipItem) Then
               Return False
        End If
           
        Dim myIds As Variant
        If TryGetIds(ipItem, myIds) Then
            Return (myIds(e_GenreField.m_Holder) = e_Holder.m_ItemByIndex0)
        End If
        
        Return False
        
    End Function

    Public Function IsNotItemByIndex0(ByRef ipItem As Variant) As Boolean
        Return (Not IsItemByIndex0(ipItem))
    End Function


    '@Description("Returns True if ipItem is a container where Items are retrieved by an Item method using a Key.  e.g. cHashD, Scripting.Dictionary, Kvp classes")
    Public Function IsItemByKey(ByRef ipItem As Variant) As Boolean
    	
        If Not VBA.IsObject(ipItem) Then
               Return False
        End If
           
        Dim myIds As Variant
        If TryGetIds(ipItem, myIds) Then
           Return (myIds(e_GenreField.m_Holder) = e_Holder.m_ItemByKey)
        End If
        
        Return False
        
    End Function

    Public Function IsNotItemByKey(ByRef ipItem As Variant) As Boolean
        Return (Not IsItemByKey(ipItem))
    End Function


    '@Description("True if ipItem is a container where an index can be used only after the items are extracted using the built in ToArray method.  e.g. mscorlib Stack, Queue")
    Public Function IsItemByToArray(ByRef ipItem As Variant) As Boolean
    	
        If Not VBA.IsObject(ipItem) Then
               Return False
        End If
           
        Dim myIds As Variant
        If TryGetIds(ipItem, myIds) Then
           Return (myIds(e_GenreField.m_Holder) = e_Holder.m_ItemByToArray)
        End If
        
        Return False
        
    End Function

    Public Function IsNotItemByToArray(ByRef ipItem As Variant) As Boolean
        Return (Not IsItemByToArray(ipItem))
    End Function


    Public Function IsMapper(ByRef ipItem As Variant) As Boolean
    	
        If Not VBA.IsObject(ipItem) Then
               Return False
        End If
           
        Dim myIds As Variant
        If TryGetIds(ipItem, myIds) Then
            Return (myIds(e_GenreField.m_Holder) And e_Holder.m_Mapper)
        End If
        
        Return False
        
    End Function

    Public Function IsNotMapper(ByRef ipItem As Variant) As Boolean
        Return (Not IsMapper(ipItem))
    End Function
    

'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
'Methods specific to the additional functionality we require for the TypeInfo class
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
    /* Freedom lib defined all variables as having at least one set of bounds
    The bounds are defined as per the table below
    
    '                           Ranks   FirstBound  LastBound
    ' Simple variables          0       1           1
    ' Strings                   1       1           VBA.Len
    ' mpObjects                 0       1           1 for default value
    ' Udt                       0       0           -1
    ' narrays and uarrays       0       0           -1
    ' pArrays/Matrix            cDIms   Lbound      Ubound for each rank
    ' ItemByIndex0              1       0           Count -1
    ' ItemByIndex1              1       1           Count
    ' ItemByToArray             1       0           Count -1
    ' ItemKey                   1       1           Count
    
    As part of thi definition we also do the dodgy thing og defining that simple variables/udt//narray and uarray 
    return 0 for the ranks method **BUT** still allow a first/Last index.  
    This is done to simplify coding as it allows all variables to be treated in the same manner.
    */
    Public Function Bounds(ByRef ipItem As Variant) As Variant
        Dim myRanks As Long = Me.Ranks(ipItem)
        Dim myBounds As Variant
        ReDim myBounds(1 To myRanks, 0 To 1)
        Dim myRank As Long
        For myRank = 1 To myRanks
            myBounds (myRank, 0) = Me.FirstIndex(ipItem)
            myBounds (myRank, 1) = Me.LastIndex(ipItem)
        Next
        Return myBounds
    End Function
    
    [Description("True if the array has been defined but not dimmed.  e.g. Dim myArray() as long")]
    Public Function IsNArray(ByRef ipItem As Variant) As Boolean
        Dim myIds As Variant
        If TryGetIds(ipItem, myIds) Then
            Return (myIds(e_GenreField.m_FLib) = e_Id.m_NArray)
        End If
        Return False
    End Function
        
    Public Function IsNotNArray(ByRef ipItem As Variant) As Boolean
        Return (Not IsNArray(ipItem))
    End Function
        
    
    [Description("True if the array has an allocated safearray structure but has not been dimmed, e.g. Dim myArray as Variant = Array()")]
    Public Function IsUArray(ByRef ipItem As Variant) As Boolean
        Dim myIds As Variant
        If TryGetIds(ipItem, myIds) Then
            Return (myIds(e_GenreField.m_FLib) = e_Id.m_UArray)
        End If
        Return False
    End Function
        
    Public Function IsNotUArray(ByRef ipItem As Variant) As Boolean
        Return (Not IsUArray(ipItem))
    End Function
    
    
    [Description("True if the array has been dimmed.  e.g. Dim Arrayx to y) as long, or redim myArray(x to y)")]
    Public Function IsPArray(ByRef ipItem As Variant) As Boolean
        Dim myIds As Variant
        If TryGetIds(ipItem, myIds) Then
            Return (myIds(e_GenreField.m_FLib) = e_Id.m_PArray)
        End If
        Return False
    End Function
        
    Public Function IsNotPArray(ByRef ipItem As Variant) As Boolean
        Return (Not IsPArray(ipItem))
    End Function
    
    
    Public Function IsMatrix(ByRef ipItem As Variant) As Boolean
        Dim myIds As Variant
        If TryGetIds(ipItem, myIds) Then
            Return (myIds(e_GenreField.m_FLib) = e_Id.m_Matrix)
        End If
        Return False
    End Function
        
    Public Function IsNotMatrix(ByRef ipItem As Variant) As Boolean
        Return Not IsMatrix(ipItem)
    End Function
    

    ' See comments for Bounds method
    [Description("Returns the first index of the specified rank.")]
    Public Function FirstIndex(ByRef ipItem As Variant, Optional ipRank As Long = 1) As Long
        
        Contract.HasId ipItem, MY_LOC & CurrentProcedureName
        
        Dim myIds As Variant
        If Not TryGetIds(ipItem, myIds) Then
            Err.Raise 17 + vbObjectError
        End If
    
        ' deal with variables that are not holders
        ' return 0 in the case of narray and uarray
        If myIds(e_GenreField.m_Holder) = e_Holder.m_IsNotHolder Then
        	Select Case myIds(e_GenreField.m_FLib)
                Case e_Id.m_Missing, e_Id.m_UDT, e_Id.m_NArray, e_Id.m_UArray
                    Return 0
                Case Else
                    Return 1
            End Select
        End If
        
        ' check that the iprank value is compatible with the holder type
        ' narrays and uarrays are not classified as holders
        If myIds(e_GenreField.m_Holder) = e_Holder.m_Array Then
        	Contract.IsInNumRange ipRank, 1, Unsafe.SADims(ipItem), "FreedomLib.Fbase.TypeInfo.FirstIndex"
        Else
        	Contract.IsValue ipRank, 1, "FreedomLib.Fbase.TypeInfo.FirstIndex"
        End If
        
        Select Case myIds(e_GenreField.m_Holder)
            
            Case e_Holder.m_Array
                ' n and u arrays were filtered out earlier as they are not considered to be 'holders'
                Return LBound(ipItem, ipRank)
                
            Case e_Holder.m_ItemByIndex0
                Return 0&
            Case e_Holder.m_ItemByIndex1
                Return 1&
            Case e_Holder.m_String
                Return 1&
            Case e_Holder.m_ItemByKey
                Return 1&
            Case e_Holder.m_ItemByToArray
                Return 0&
        End Select
        
    End Function

    [Description("Returns the last index of the specified rank. Returns -1 for non-holder. Defaults to rank 1 for holders)")]
    Public Function LastIndex(ByRef ipItem As Variant, Optional ipRank As Long = 1) As Variant
        
        Dim myIds As Variant
        If Not TryGetIds(ipItem, myIds) Then
            Err.Raise 17 + vbObjectError
        End If
        
        ' deal with variables that are not holders
        ' return 0 in the case of narray and uarray
        If myIds(e_GenreField.m_Holder) = e_Holder.m_IsNotHolder Then
            Select Case myIds(e_GenreField.m_FLib)
                Case e_Id.m_Missing, e_Id.m_NArray, e_Id.m_UArray, e_Id.m_UDT
                    Return -1&
            
                Case Else
                    Return 1&
                    
            End Select
            
        End If
        
        ' check that the iprank value is compatible with the holder type
        ' narrays and uarrays are not classified as holders
        If myIds(e_GenreField.m_Holder) = e_Holder.m_Array Then
            Contract.IsInNumRange ipRank, 1, Unsafe.SADims(ipItem), "FreedomLib.Fbase.TypeInfo.FirstIndex"
        Else
            Contract.IsValue ipRank, 1, "FreedomLib.Fbase.TypeInfo.FirstIndex"
        End If
        
        Select Case myIds(e_GenreField.m_Holder)
            
            Case e_Holder.m_Array
                ' n and u arrays were filtered out earlier as they are not 'holders'
                
                Return UBound(ipItem, ipRank)
            
            Case e_Holder.m_ItemByIndex0
                Return ipItem.count - 1
            Case e_Holder.m_ItemByIndex1
                Return ipItem.count
            Case e_Holder.m_String
                Return VBA.Len(ipItem)
            Case e_Holder.m_ItemByKey
                Return ipItem.count
            Case e_Holder.m_ItemByToArray
                Return ipItem.count - 1
        End Select
    End Function

    [Description("Returns True if variable is a holder type and contins 1 or more values")]
    Public Function HoldsItems(ByRef ipItem As Variant) As Boolean
        Dim myIds As Variant
        If Not TryGetIds(ipItem, myIds) Then
            Err.Raise 17 + vbObjectError
        End If
        
        Select Case myIds(e_GenreField.m_Holder)
            
            Case e_Holder.m_IsNotHolder
                Return False
                
            Case e_Holder.m_Array
            
                Select Case myIds(e_GenreField.m_FLib)
                    Case e_Id.m_PArray
                        Return True
                End Select
                
            Case e_Holder.m_String
                Return VBA.Len(ipItem) > 0
                
            Case Else
            
                Return ipItem.count > 0
                
        End Select
    End Function

    Public Function LacksItems(ByRef ipItem As Variant) As Boolean
        Return Not HoldsItems(ipItem)
    End Function

    [Description("Returns the number of elements in ipItem." & vbcrlf & _
    " Counts are generated as follows" & vbcrlf & _
    "- Non Indexable Items = 1" & vbcrlf & _
    "- Uninitialised array = -1" & vbcrlf & _
    "- Array with specified rank - Size of rank" & vbcrlf & _
    "- Array with no specified rank = total number of elements in array (product of rank sizes)" & vbcrlf & _
    "- String = Len(ipItem)" & vbcrlf & _ 
    "- Container = the result of the .Count method")]
    [Description("returns the number of values per access method represented by the variable. Non holders are 1, empty holders and unallocated arrays return -1,")]
    Public Function Count(ByRef ipItem As Variant, Optional ipRank As Long = 0) As Variant
        
        'Contract.HasId ipItem, MY_LOC & CurrentProcedureName
        'Contract.IsInNumRange ipRank, 0, Me.Ranks(ipItem), MY_LOC & CurrentProcedureName
        
        Dim myIds As Variant
        If Not TryGetIds(ipItem, myIds) Then
            Return -1
        End If
        
        Dim myId As e_Id = myIds(e_GenreField.m_FLib)
        Select Case myId
            
            Case e_Id.m_Missing, e_Id.m_UDT, e_Id.m_NArray, e_Id.m_UArray:  Return -1&
                
            'Case e_Id.m_mpObject:                           Return 1&
                
            Case e_Id.m_PArray
                If ipRank > 0 Then
                    Return UBound(ipItem, ipRank) - LBound(ipItem, ipRank) + 1
                End If
                Dim myRank As Long
                Dim myCount As Long = 1
                For myRank = 1 To Unsafe.SADims(ipItem)
                    myCount *= UBound(ipItem, myRank) - LBound(ipItem, myRank) + 1
                Next
                Return myCount
                
            Case e_Id.m_Matrix:                                             Return Matrix.Count(ipRank)
            Case e_Id.m_String:                                             Return VBA.Len(ipItem)
                
        End Select
                
        Select Case myIds(e_GenreField.m_Group)
            Case e_Group.m_Admin:                                           Return 1&
            Case e_Group.m_mpObject:                                        Return 1&
        End Select
        
        Select Case myIds(e_GenreField.m_Entity)
            
            Case e_Entity.m_Simple:                                         Return 1&
            Case e_Entity.m_Object:                                         Return ipItem.COUNT
            Case Else:                                                      Return 1&
        End Select
                
        
        
    End Function

    '[ Description ("Returns true if the variable is a single dimension array populated with a single item which is a single dimension array (i.e. a forwarded paramarray))]
    Public Function IsLikeParamArray(ByRef ipItem As Variant) As Boolean
    	
        Dim myIds As Variant
        If Not TryGetIds(ipItem, myIds) Then
            Return False
        End If
        
        Return myIds(e_VarGenre.m_FLib) = e_Id.m_PArray
        
    	' If Not VBA.IsArray(ipItem) Then
        ' 	Return False
    	' End If
        
        ' If Not VBA.IsArrayInitialized(ipItem) Then
        ' 	Return False
        ' End If
        
        ' If UBound(ipItem, 1) <> LBound(ipItem(1)) Then
        ' 	Return False
        ' End If
        
        ' If Not VBA.IsArray(ipItem(0)) Then
        ' 	Return False
        ' End If
        
        ' If LBound(ipItem(0)) <> UBound(ipItem(0)) Then
        '     Return False
        ' End If
        
        ' Return True
        
    End Function


    [Description(" returns the number of ranks represented by a variable, non holders return 0, arrays return the number of dimensuons otherwise 1")]
    Public Function Ranks(ByRef ipItem As Variant) As Long
        
        Contract.HasId ipItem, MY_LOC & CurrentProcedureName
        
        Dim myIds As Variant = s.FNameToIds(Me.Name(ipItem))
        
        Select Case myIds(e_GenreField.m_FLib)
            
            Case e_Id.m_UDT, e_Id.m_mpObject, e_Id.m_NArray, e_Id.m_UArray: Return 0
                
            Case e_Id.m_PArray:                                             Return Unsafe.SADims(ipItem)
            Case e_Id.m_Matrix:                                             Return ipItem.Ranks
                
            Case e_Id.m_String:                                             Return 1
            
            Case Else
                
                Select Case myIds(e_GenreField.m_Entity)
                    
                    Case e_Entity.m_Simple:                                 Return 0
                    Case e_Entity.m_Object:                                 Return 1
                        
                End Select
                
        End Select
        
    End Function

    ' Description ("Returns true if the rank is supported")
    Public Function HoldsRank(ByRef ipItem As Variant, ByVal ipRank As Long) As Boolean
        
        Contract.HasId ipItem, MY_LOC & CurrentProcedureName
        
        Dim myRanks As Long = Me.Ranks(ipItem)
        
        If ipRank = 0 And myRanks = 0 Then
            Return True
        Else
            Return (ipRank >= 1) And (ipRank <= myRanks)
        End If
        
    End Function

    Public Function LacksRanks(ByVal ipRank As Long, ByRef ipArray As Variant) As Boolean
        Return Not HoldsRank(ipRank, ipArray)
    End Function
    
    

    [Description("Returns the name 'TypeInfo'")]
    Public Property Get TypeName() As String
    	Return MY_TYPENAME
    End Property
    
    Private Sub TypeNotAssigned(ByRef ipItem As Variant, ByRef ipLoc As String)
    	Err.Raise 17 + vbObjectError, _
            MY_LOC & ipLoc, _
            "Type " & VBA.TypeName(ipItem) & " not known to FreedomLib"
    End Sub

'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
'Convenience methods
'========1=========2=========3=========4=========5=========6=========7=========8=========9=========A=========B=========
    
Public Property Get IsCollection(ByRef ipITem As Variant) As Boolean
    Return VBA.TypeName(ipITem) = "Collection"
End Property
End Class